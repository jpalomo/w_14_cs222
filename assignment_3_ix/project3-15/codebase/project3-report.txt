Our implementation uses the standard B+ tree methods and algorithms from the book.  When the B+ tree is initially created, we allocate the pages required for the root and one leaf page.  Additionally, each of these pages will have a header that contains information such as free space available, the free space offset for the data entries to be inserted, page type, number of records, and next/previous pages in the case of leaf pages.   After the header of each page, we have sequence of structures called, slots, that correspond to the data entries on each page.  Slots are allocated contiguously after the header and contain the information like offset and length corresponding to the data entry offset and length.  Data entries are stored at the bottom of our page.  

I guess our page implementation can viewed as two stacks growing towards each other.  When the free space available is not enough for a new entry that needs to be inserted, the page is split and a structure called ‘splitInfo’ is passed up to the calling level to either copy/push the split info value up.  In the event of a split, we have a couple of utility methods that copy half the records from the current page over to the newly allocated page.  We update the ‘hanging’ pointer and populate the slot info to pass it back up.  Additionally, since the page from which the records were copied from may have fragmented data because the entries no longer exists, we reorganize the page so that the next insert into this page will be successful.

In the event of a delete, we simple remove the required slot information ensuring that all slots are contiguous after the delete.  The actually data entry still remains on the page until a reorganization is needed after which they will be removed.

Inserting into the B+ tree is done using a binary search method.  Given a key to insert, we binary search the slots and read their corresponding values that they point to since all slots are maintained in order according to their data entry value.  Once we have the slot to insert to, if the new entry is not being insert into the end, we need to shift the slots down to make room.  No pointer values need to be updated because the slots contain the absolute offsets of each of their respective entries.
